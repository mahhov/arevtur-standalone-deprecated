<style>
	#results-container {
		display: flex;
		align-items: flex-start;
		margin-top: 30px;
	}

	#results-list {
		flex: 1;
	}

	#results-list .item {
		margin: 10px;
	}
</style>

<script>
	require('./xElements/import');
</script>

<x-inputs></x-inputs>
<div id="results-container">
	<div>Count: <span id="results-count"></span></div>
	<div id="results-progress"></div>
	<div id="results-list"></div>
	<x-chart id="results-chart" width="400" height="400"></x-chart>
</div>

<script>
	const {XElement} = require('xx-element');
	const DataFetcher = require('./DataFetcher');

	const $ = document.querySelector.bind(document);
	const $$ = document.querySelectorAll.bind(document);
	const $c = (tag, classList = [], text = '', parent = null) => {
		let el = document.createElement(tag);
		el.classList.add(...classList);
		el.textContent = text;
		if (parent)
			parent.appendChild(el);
		return el;
	};

	let submitQuery = async add => {
		let query = $('x-inputs').query;
		let itemsDataNew = await DataFetcher.getItems(query, progress =>
			$c('div', [], progress, $('#results-progress')));
		XElement.clearChildren($('#results-progress'));
		if (add) {
			// todo make ItemsData class
			itemsData.items = itemsData.items.concat(itemsDataNew.items)
				.filter((v, i, a) => a.findIndex(vv => vv.id === v.id) === i);
			itemsData.total += itemsDataNew.items.total;
		} else
			itemsData = itemsDataNew;
		// high to low values, low to high prices
		itemsData.items = itemsData.items.sort((a, b) =>
			b.evalValue - a.evalValue || a.evalPrice - b.evalPrice);

		let itemsToPoints = items =>
			items.map(item => ({x: item.evalPrice, y: item.evalValue}));

		$('#results-chart').pointSets = [
			{
				color: 'rgb(0,0,0)',
				size: 4,
				points: itemsToPoints(itemsData.items),
			}, {
				color: 'rgb(0,0,255)',
				size: 6,
				points: itemsToPoints(getBorderlineItems(itemsData.items)),
			},
		];

		XElement.clearChildren($('#results-list'));
		itemsData.items.forEach(itemData =>
			$c('x-item-listing', ['item'], '', $('#results-list')).itemData = itemData);

		$('#results-count').textContent = itemsData.items.length
	};

	let getBorderlineItems = itemsSorted => {
		let minPrice = Infinity;
		return itemsSorted.filter(item => {
			if (item.evalPrice >= minPrice)
				return false;
			minPrice = item.evalPrice;
			return true;
		});
	};

	let itemsData = [];
	$('x-inputs').addEventListener('submit', e => submitQuery(e.detail.add));

	// todo
	// query all active item sets
	// draw chart exhausted rects
	// click chart to requery
	// ctrl click submit to add query
	// multiple queries and sharing filter groups
	// submit query on load
	// query by name
	// expand price range
	// convert armor and socket requirements to fuzzy query
	// assume quality 0%
	// free affixes
	// search results text
	// x-model setter on same value
	// default query property filter
	// pin item list

</script>
